{"version":3,"sources":["lib/LinkedListNode.js","Board/Snake.js","lib/LinkedList.js","Board/Board.jsx","lib/utils.js","App.js","index.js"],"names":["LinkedListNode","value","this","next","Snake","getHead","tail","getTail","head","addHead","addLast","removeTail","removeFirst","addFirst","node","curHead","curTail","removeLast","Direction","getSnakeStartValue","board","rowSize","length","colSize","startRow","Math","round","startCol","row","col","cell","createBoard","boardSize","counter","currentRow","push","getDirectionFromKey","key","getOppositeDirection","direction","getNextCoords","coords","hasBoundary","newCoords","isOutOfBounds","getCellClassName","cellValue","foodCell","snakeCells","has","Board","useState","snake","setSnake","Set","setSnakeCells","setDirection","setFoodCell","score","setScore","topScore","setTopScore","speed","stop","setStop","useEffect","handleKeydown","e","newDirection","size","window","addEventListener","removeEventListener","callback","delay","savedCallback","useRef","current","id","setInterval","clearInterval","useInterval","moveSnake","curHeadCoords","nextHeadCoords","nextHeadCell","handleGameOver","newSnakeCells","add","delete","handleFoodConsumption","nextFoodCell","floor","BOARD_SIZE","random","s","newSnake","className","map","rowIdx","cellIdx","App","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.4c989f7e.chunk.js","sourcesContent":["class LinkedListNode {\n    constructor(value) {\n        this.value = value;\n        this.next = null;\n    }\n}\n\nexport default LinkedListNode;","import LinkedList from \"../lib/LinkedList\";\n\nclass Snake extends LinkedList {\n    getHead = () => this.tail;\n\n    getTail = () => this.head;\n\n    addHead = (value) => this.addLast(value);\n\n    removeTail = () => this.removeFirst();\n}\n\nexport default Snake;","import LinkedListNode from './LinkedListNode'\n\nclass LinkedList {\n    constructor(value) {\n        const node = new LinkedListNode(value);\n        this.head = node;\n        this.tail = node;\n    }\n\n    addFirst = (value) => {\n        const node = new LinkedListNode(value);\n        const curHead = this.head;\n        this.head = node;\n        node.next = curHead;\n        if (this.tail === null) {\n            this.tail = node;\n        }\n    };\n\n    addLast = (value) => {\n        if (this.head === null) {\n            this.addFirst(value);\n        } else {\n            const node = new LinkedListNode(value);\n            const curTail = this.tail;\n            this.tail = node;\n            curTail.next = node;\n        }\n    };\n\n    removeFirst = () => {\n        if (this.head !== null) {\n            this.head = this.head.next;\n            if (this.head === null) {\n                this.tail = null;\n            }\n        }\n    }\n\n    removeLast = () => {\n        if (this.head !== null) {\n            let node = this.head;\n            if (node.next == null) {\n                this.head = null;\n                this.tail = null;\n            }\n            else {\n                while (node.next !== null && node.next.next !== null) {\n                    node = node.next;\n                }\n                node.next = null;\n                this.tail = node;\n            }\n        }\n    };\n}\n\nexport default LinkedList;","import React, { useState, useEffect } from 'react';\nimport {\n    useInterval,\n} from '../lib/utils.js';\n\nimport './Board.css';\nimport Snake from './Snake';\n\nconst BOARD_SIZE = 15;\nconst SNAKE_SPEED = 100;\nconst INITIAL_FOOD_DISTANCE = 5\n\nconst Direction = {\n    UP: 'UP',\n    RIGHT: 'RIGHT',\n    DOWN: 'DOWN',\n    LEFT: 'LEFT',\n};\n\n\nconst getSnakeStartValue = board => {\n    const rowSize = board.length;\n    const colSize = board[0].length;\n    const startRow = Math.round(rowSize / 3);\n    const startCol = Math.round(colSize / 3);\n    const startCell = board[startRow][startCol];\n    return {\n        row: startRow,\n        col: startCol,\n        cell: startCell,\n    };\n};\n\nconst Board = () => {\n    const [board, setBoard] = useState(createBoard(BOARD_SIZE));\n    const [snake, setSnake] = useState(new Snake(getSnakeStartValue(board)));\n    const [snakeCells, setSnakeCells] = useState(new Set([snake.getHead().value.cell]));\n    const [direction, setDirection] = useState(Direction.RIGHT);\n    const [hasBoundary, setHasBoundary] = useState(false);\n    const [foodCell, setFoodCell] = useState(snake.getHead().value.cell + INITIAL_FOOD_DISTANCE);\n    const [score, setScore] = useState(0);\n    const [topScore, setTopScore] = useState(0);\n    const [speed, setSpeed] = useState(SNAKE_SPEED);\n    const [stop, setStop] = useState(false);\n\n    // Handle keydown event.\n    useEffect(() => {\n        const handleKeydown = e => {\n            // Press Enter to pause or resume.\n            if (e.key === 'Enter') {\n                setStop(!stop);\n            } else if (!stop) {\n                const newDirection = getDirectionFromKey(e.key);\n                // Ignore the cases\n                // 1. input key not arrow directions,\n                // 2. or new direction is the opposite of the original one \n                // when the snake's size is more than one.\n                if (newDirection === null ||\n                    (getOppositeDirection(newDirection) === direction && snakeCells.size > 1))\n                    return;\n                setDirection(newDirection);\n            }\n        };\n\n        window.addEventListener('keydown', handleKeydown);\n        return () => window.removeEventListener('keydown', handleKeydown);\n    }, [stop, direction, snakeCells.size]);\n\n    // Handle scores\n    useEffect(() => {\n        if (score > topScore) {\n            setTopScore(score);\n        }\n    }, [score, topScore])\n\n    // Handle snake's move.\n    useInterval(() => {\n        moveSnake();\n    }, !stop ? speed : null);\n\n    const moveSnake = () => {\n        const curHeadCoords = {\n            row: snake.getHead().value.row,\n            col: snake.getHead().value.col\n        };\n\n        const nextHeadCoords = getNextCoords(curHeadCoords, direction, board, hasBoundary);\n        const nextHeadCell = board[nextHeadCoords.row][nextHeadCoords.col];\n\n        if ((hasBoundary && isOutOfBounds(nextHeadCoords, board)) || snakeCells.has(nextHeadCell)) {\n            handleGameOver();\n            return;\n        }\n\n        snake.addHead({\n            row: nextHeadCoords.row,\n            col: nextHeadCoords.col,\n            cell: nextHeadCell\n        });\n\n        const newSnakeCells = new Set(snakeCells);\n        newSnakeCells.add(nextHeadCell);\n\n        if (nextHeadCell !== foodCell) {\n            newSnakeCells.delete(snake.getTail().value.cell);\n            snake.removeTail();\n        } else {\n            handleFoodConsumption(newSnakeCells);\n        }\n\n        setSnake(snake);\n        setSnakeCells(newSnakeCells);\n    }\n\n    const handleFoodConsumption = newSnakeCells => {\n        const maxCellValue = BOARD_SIZE * BOARD_SIZE;\n        let nextFoodCell = null;\n        while (nextFoodCell === null || newSnakeCells.has(nextFoodCell)) {\n            nextFoodCell = Math.floor(Math.random() * maxCellValue + 1);\n        }\n        setFoodCell(nextFoodCell);\n        setScore(s => s + 1);\n    }\n\n    const handleGameOver = () => {\n        const newSnake = getSnakeStartValue(board);\n        setSnake(new Snake(newSnake));\n        setSnakeCells(new Set([newSnake.cell]));\n        setDirection(Direction.RIGHT);\n        setFoodCell(newSnake.cell + INITIAL_FOOD_DISTANCE)\n        setScore(0);\n    }\n\n    return (\n        <div className=\"board\">{\n            board.map((row, rowIdx) => (\n                <div key={rowIdx} className=\"row\">{\n                    row.map((cellValue, cellIdx) => (\n                        <div\n                            key={cellIdx}\n                            className={getCellClassName(cellValue, foodCell, snakeCells)}>\n                        </div>\n                    ))\n                }</div>\n            ))\n        }\n            <div className=\"score-row\">\n                <div className=\"score-cell\">\n                    <span>Score: {score}</span>\n                </div>\n                <div className=\"score-cell\">\n                    <span>Top Score: {topScore}</span>\n                </div>\n            </div>\n        </div>\n    );\n};\n\nconst createBoard = boardSize => {\n    let counter = 1;\n    const board = [];\n    for (let row = 0; row < boardSize; row++) {\n        const currentRow = [];\n        for (let col = 0; col < boardSize; col++) {\n            currentRow.push(counter++);\n        }\n        board.push(currentRow);\n    }\n    return board\n}\n\nconst getDirectionFromKey = key =>\n    key === 'ArrowUp' ? Direction.UP :\n        key === 'ArrowRight' ? Direction.RIGHT :\n            key === 'ArrowDown' ? Direction.DOWN :\n                key === 'ArrowLeft' ? Direction.LEFT : null;\n\nconst getOppositeDirection = direction =>\n    direction === Direction.UP ? Direction.DOWN :\n        direction === Direction.RIGHT ? Direction.LEFT :\n            direction === Direction.DOWN ? Direction.UP :\n                direction === Direction.LEFT ? Direction.RIGHT : null;\n\nconst getNextCoords = (coords, direction, board, hasBoundary) => {\n    const newCoords = direction === Direction.UP ? {\n        row: coords.row - 1,\n        col: coords.col\n    } : direction === Direction.RIGHT ? {\n        row: coords.row,\n        col: coords.col + 1\n    } : direction === Direction.DOWN ? {\n        row: coords.row + 1,\n        col: coords.col\n    } : direction === Direction.LEFT ? {\n        row: coords.row,\n        col: coords.col - 1\n    } : {\n        row: coords.row,\n        col: coords.col\n    };\n    return hasBoundary ? newCoords : {\n        row: newCoords.row < 0 ? board.length - 1 : newCoords.row >= board.length ? 0 : newCoords.row,\n        col: newCoords.col < 0 ? board[0].length - 1 : newCoords.col >= board[0].length ? 0 : newCoords.col\n    };\n}\n\nconst isOutOfBounds = (coords, board) => {\n    const { row, col } = coords;\n    return row < 0 || col < 0 || row >= board.length || col >= board[0].length\n};\n\nconst getCellClassName = (cellValue, foodCell, snakeCells) =>\n    snakeCells.has(cellValue) ? 'cell snake-cell' : cellValue === foodCell ? 'cell food-cell' : 'cell';\n\nexport default Board;","import { useEffect, useRef } from 'react';\n\n// Copied from https://overreacted.io/making-setinterval-declarative-with-react-hooks/\nexport function useInterval(callback, delay) {\n    const savedCallback = useRef();\n\n    // Remember the latest callback.\n    useEffect(() => {\n        savedCallback.current = callback;\n    }, [callback]);\n\n    // Set up the interval.\n    useEffect(() => {\n        function tick() {\n            savedCallback.current();\n        }\n        if (delay !== null) {\n            let id = setInterval(tick, delay);\n            return () => clearInterval(id);\n        }\n    }, [delay]);\n}","import Board from './Board/Board'\nimport './App.css';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Board></Board>\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}